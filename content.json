{"meta":{"title":"xyongs' blog","subtitle":null,"description":null,"author":"xyongs","url":"https://goolory.github.io","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2020-03-17T03:05:56.836Z","updated":"2020-03-17T03:05:56.836Z","comments":false,"path":"/404.html","permalink":"https://goolory.github.io/404.html","excerpt":"","text":""},{"title":"关于","date":"2020-03-17T03:05:56.880Z","updated":"2020-03-17T03:05:56.880Z","comments":false,"path":"about/index.html","permalink":"https://goolory.github.io/about/index.html","excerpt":"","text":"姓名 xys e-mail yoonsheg@gmail.com"},{"title":"书单","date":"2020-03-17T03:05:56.881Z","updated":"2020-03-17T03:05:56.881Z","comments":false,"path":"books/index.html","permalink":"https://goolory.github.io/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2020-03-17T03:05:56.881Z","updated":"2020-03-17T03:05:56.881Z","comments":false,"path":"categories/index.html","permalink":"https://goolory.github.io/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2020-03-17T03:05:56.881Z","updated":"2020-03-17T03:05:56.881Z","comments":true,"path":"links/index.html","permalink":"https://goolory.github.io/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2020-03-17T03:05:56.881Z","updated":"2020-03-17T03:05:56.881Z","comments":false,"path":"repository/index.html","permalink":"https://goolory.github.io/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-03-17T03:05:56.881Z","updated":"2020-03-17T03:05:56.881Z","comments":false,"path":"tags/index.html","permalink":"https://goolory.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Hexo使用","slug":"hello-world","date":"2020-03-17T03:05:56.844Z","updated":"2020-03-17T03:12:39.955Z","comments":true,"path":"2020/03/17/hello-world/","link":"","permalink":"https://goolory.github.io/2020/03/17/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"日常","slug":"日常","permalink":"https://goolory.github.io/categories/%E6%97%A5%E5%B8%B8/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://goolory.github.io/tags/hexo/"}]},{"title":"基本算法思想","slug":"基本算法思想","date":"2019-11-25T14:21:44.000Z","updated":"2020-03-17T03:12:39.886Z","comments":true,"path":"2019/11/25/基本算法思想/","link":"","permalink":"https://goolory.github.io/2019/11/25/%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/","excerpt":"","text":"基本算法思想贪心算法五分钟了解一下什么是「贪心算法 」 （1）建立数学模型来描述问题。（2）把求解的问题分成若干个子问题。（3）对每一子问题求解，得到子问题的局部最优解。（4）把子问题的局部最优解合成原来问题的一个解。 动态规划有了四步解题法模板，再也不害怕动态规划！ （进阶版）有了四步解题法模板，再也不害怕动态规划！ （再进阶版）有了四步解题法模板，再也不害怕动态规划！ 看动画轻松理解「递归」与「动态规划」 浅谈什么是动态规划以及相关的「股票」算法题 深度解析「正则表达式匹配」：从暴力解法到动态规划 用一句话解释动态规划就是 “记住你之前做过的事”，如果更准确些，其实是 “记住你之前得到的答案”。 一般解决动态规划问题，分为四个步骤，分别是 问题拆解，找到问题之间的具体联系 状态定义 递推方程推导 实现 分治算法 浅谈什么是分治算法 分治法在每一层递归上都有三个步骤： （1）分解：将原问题分解为若干个规模较小，相互独立，与原问题形式相同的子问题。 （2）求解：若子问题规模较小而容易被解决则直接解，否则递归地解各个子问题。 （3）合并：将各个子问题的解合并为原问题的解。 作者：程序员吴师兄呀 3、排序算法「多图警告」手撕排序算法 – iOS进阶必备 十大经典排序算法动画与解析，看我就够了！（配代码完全版） 这或许是东半球分析十大排序算法最好的一篇文章 4、搜索几道和「广度优先搜索」有关的算法面试题 初识广度优先搜索与解题套路 从简单二叉树问题重新来看深度优先搜索 5、查找二分查找算法详解 一网打尽！二分查找解题模版与题型全面解析 面试官，我会写二分查找法！对，没有 bug 的那种！ 6、字符串匹配动画：BM 算法中的坏字符规则与好后缀规则 动画：七分钟理解什么是KMP算法 动画：什么是 BF 算法 ？ 动态规划之 KMP 算法详解（配代码版） 7、线性表如何高效对有序数组/链表去重？ 超详细！详解一道高频算法题：数组中的第 K 个最大元素 一道简单的数组遍历题，加上四个条件后感觉无从下手 数组特性的妙用！如何找到「缺失的第一个正数」 剑指 offer 第一题：二维数组中的查找 动画：什么是单调栈？ 在数据结构中穿针引线：链表实现栈和队列 从简单的线性数据结构开始：栈与队列 五分钟学算法小知识：用栈实现队列/用队列实现栈 几道和「堆栈、队列」有关的面试算法题 超详细！图解「合并 K 个排序链表」 动画：面试如何轻松手写链表？ LeetCode 上最难的链表算法题，没有之一！ 链表算法面试问题？看我就够了！ 看动画轻松理解「链表」实现「LRU缓存淘汰算法」 从简单的线性数据结构开始：穿针引线的链表（一） 在数据结构中穿针引线：链表实现栈和队列 8、散列表五分钟速读：什么是散列表（哈希表）？ 什么是哈希洪水攻击（Hash-Flooding Attack）？ 几道和散列（哈希）表有关的面试题 如何判断一个元素在亿级数据中是否存在？ 9、树面试前准备：二叉树高频面试题和答案 懵逼树上懵逼果：学习二分搜索树 LeetCode 二叉树问题小总结 从简单二叉树问题重新来看深度优先搜索 几道和「二叉树」有关的算法面试题 详解什么是平衡二叉树（AVL）（修订补充版） 【面试现场】为什么 MySQL 数据库要用B+树存储索引？ 字典树概念与题型解析 面试官：为什么 MySQL 的索引要使用 B+ 树，而不是其它树？比如 B 树？ 心里没点 B 树。。。 数据结构与算法——最小生成树 植树节，程序猿种的那些树 数据结构与算法——2-3-4树 数据结构与算法——2-3树 看动画轻松理解「Trie树」 10、图浅谈什么是图拓扑排序 数据结构与算法——图论基础与图存储结构 数据结构与算法：三十张图弄懂「图的两种遍历方式」 数据结构与算法——图最短路径 【转】知乎","categories":[{"name":"算法","slug":"算法","permalink":"https://goolory.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://goolory.github.io/tags/Java/"}]},{"title":"OLSR数据包格式与转发","slug":"OLSR数据包格式与转发","date":"2019-11-22T15:08:37.000Z","updated":"2020-03-17T03:05:56.836Z","comments":true,"path":"2019/11/22/OLSR数据包格式与转发/","link":"","permalink":"https://goolory.github.io/2019/11/22/OLSR%E6%95%B0%E6%8D%AE%E5%8C%85%E6%A0%BC%E5%BC%8F%E4%B8%8E%E8%BD%AC%E5%8F%91/","excerpt":"","text":"数据包格式与转发OLSR使用与协议相关的所有数据的统一数据包格式进行通信。这样做的目的是在不破坏向后兼容性的情况下促进协议的可扩展性。这也提供了一种简单的方式，将不同“类型”的信息承载到单个传输中，从而为给定的实现优化利用网络提供的最大帧大小。这些数据包被嵌入UDP数据报在网络上传输。本文档使用IPv4地址。关于IPv6的考虑在第17节中给出。 每个包封装一个或多个消息。这些消息共享一个公共的头格式，这使节点能够正确地接受和(如果适用的话)重新传输未知类型的消息。 消息可以被淹没到整个网络中，或者可以将淹没限制在距离消息始发者直径(以跳数表示)以内的节点上。因此，将消息传递给节点的邻居只是洪泛的一个特例。当淹没任何控制消息时，重复的重发将在本地被消除(即，每个节点都维护一个重复的集合，以防止发送相同的OLSR控制消息两次)，并通过使用MPRs在整个网络中最小化。 此外，节点可以检查消息的标头，以获得关于到消息发送者的距离(以跳数表示)的信息。这种特性在某些情况下可能有用，例如，来自存储在节点上的接收控制消息的时间信息取决于到发送方的距离。 数据包格式OLSR中任何包的基本布局如下(省略IP和UDP报头)： Packet Length:数据包的长度(以字节为单位) Packet Sequence Number：数据包序列号 Message Type Vtime: 此字段指示在接收后多长时间内节点必须认为消息中包含的信息是有效的，除非接收到信息的最新更新。有效时间由其尾数(Vtime字段的四个最高位)和指数(Vtime字段的四个最低位)表示。换句话说 其中a为Vtime字段的四个最高位代表的整数，b为Vtime字段的四个最低位代表的整数。第18节规定了比例因子C的建议值。 Message Size:这将给出此消息的大小，以字节为单位进行计数，并从“消息类型”字段的开始到下一个“消息类型”字段的开始(或者，如果没有以下消息，则直到数据包结束)进行测量。 原地址（Originator Address）：此字段包含最初生成此消息的节点的主地址。此字段不应与来自IP报头的源地址混淆，后者每次都更改为重新传输此消息的中间接口的地址。在重发中，发起人地址字段必须“永远”不变。 生存时间（Time To Live）：此字段包含要传输的消息的最大跳数。在重新传输消息之前，生存时间必须减少1。当节点接收到时间为0或1的消息时，在任何情况下都不能重新传输该消息。通常，节点不会接收TTL为0的消息。 跳数（Hop Count）：此字段包含消息已达到的跳数。在重新传输消息之前，跳数必须增加1。 包处理和消息泛滥在接收到基本数据包后，节点检查每个“消息头”。根据“消息类型”字段的值，节点可以确定消息的命运。一个节点可以多次接收相同的消息。因此，为了避免对一些已经接收和处理的消息进行重新处理，每个节点维护一个重复集。在这个集合中，节点记录关于最近接收的消息的信息，避免对消息进行重复处理。对于这样的消息，节点记录一个“重复元组”(D_addr、D_seq_num、d_re、D_iface_list、D_time)，其中D_addr是消息的发起者地址，D_seq_num是消息的消息序列号，d_retransmission是一个布尔值，指示消息是否已被发送 已经重新传输的D_iface_list是接收到消息的接口的地址列表，D_time指定元组过期和必须删除的时间 因此，在接收到基本数据包时，节点必须为每个封装的消息执行以下任务： 如果数据包不包含任何消息(即，数据包长度小于或等于数据包报头的大小)，则必须悄悄地丢弃数据包。对于IPv4地址，这意味着当数据包长度小于16时，必须静静地丢弃数据包。 如果消息的生存时间小于或等于“0”(0)，或者消息是由接收节点发送的(即，消息的发起者地址为接收节点的主地址):消息必须被静默丢弃。 处理条件 ​ 若： ​ 12D_addr == Originator Address, ANDD_seq_num == Message Sequence Number 表示信息早已被处理，无需再处理 默认转发算法 如果未检测到消息的发送方接口地址位于节点的对称1跳邻域内，则转发算法必须在此静默停止(且不能转发消息)。 若： 12D_addr == Originator Address, ANDD_seq_num == Message Sequence Number 已收到，将进一步考虑转发消息，当且仅当; D_retransmitted is false, AND 接收到消息的接口的地址不在D_iface_list地址中 否则，如果这样的条目不存在，则进一步考虑转发消息。 如果发送方接口地址是该节点的MPR选择器的接口地址，并且消息的存活时间大于’1’，则必须重新传输消息(如后面的步骤6到8所述)。 如果重复集中存在具有相同发起者地址和相同消息序列号的项，则按以下方式更新该项: 消息的TTL减少了1。 消息的跃点计数增加1 消息在所有接口上广播(注意:消息头的其余字段应该保持不变)。","categories":[{"name":"MANET","slug":"MANET","permalink":"https://goolory.github.io/categories/MANET/"}],"tags":[{"name":"OLSR","slug":"OLSR","permalink":"https://goolory.github.io/tags/OLSR/"}]},{"title":"OLSR路由协概述","slug":"OLSR路由协议概述","date":"2019-11-22T15:03:40.000Z","updated":"2020-03-17T03:12:39.954Z","comments":true,"path":"2019/11/22/OLSR路由协议概述/","link":"","permalink":"https://goolory.github.io/2019/11/22/OLSR%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE%E6%A6%82%E8%BF%B0/","excerpt":"","text":"OLSR是一种用于移动自组网[1]、[2]的主动路由协议。它非常适合大型和密集的移动网络，因为使用MPRs实现的优化在这种情况下工作得很好。与经典的链路状态算法相比，网络越大、越密集，就可以实现越多的优化。 OLSR使用逐跳路由，即，每个节点使用其本地信息来路由包。OLSR非常适合于网络，在网络中，较大的节点集之间的流量是随机的、零星的，而不是几乎完全只在较小的特定节点集之间。作为一种主动协议，OLSR也适用于通信对随时间变化的场景:在这种情况下不会生成额外的控制流量，因为所有已知目的地都始终维护路由。 概述OLSR是一种用于移动自组织网络的主动路由协议。该协议继承了链路状态算法的稳定性，并且由于其主动性，在需要的时候可以立即使用路由。OLSR是对经典链路状态协议的优化，为移动自组织网络量身定制。 OLSR只使用选定的节点(称为MPRs)来重新传输控制消息，从而最小化控制流量泛滥带来的开销。这种技术大大减少了将消息发送到网络中所有节点所需的重发次数。其次，OLSR只需要淹没部分链路状态即可提供最短路径路径。所需的链路状态信息的最小集合是，所有选择为MPRs的节点必须将链路声明到它们的MPR选择器。额外的拓扑信息，如果存在，可以利用，例如，为冗余的目的 通过减少周期性控制消息传输的最大时间间隔，OLSR可以优化对拓扑变化的响应性。此外，由于OLSR持续维护到网络中所有目的地的路由，所以该协议对于流量模式非常有利，在这种模式中，一个大的节点子集与另一个大的节点子集通信，并且[源、目的]对随着时间而变化。该协议特别适用于大型和密集的网络，因为使用MPRs进行的优化在这种情况下工作得很好。与经典的链路状态算法相比，网络越大、越密集，就可以实现越多的优化。 OLSR被设计成以完全分布式的方式工作，不依赖于任何中心实体。该协议不需要可靠的控制消息传输:每个节点定期发送控制消息，因此可以承受一些此类消息的合理丢失。这种损失经常发生在无线电网络中，由于碰撞或其他传输问题。 而且，OLSR不需要按顺序传递消息。每个控制消息包含一个序列号，序列号为每个消息递增。因此，如果需要，控制消息的接收者可以很容易地识别哪些信息是最近的—即使消息在传输过程中被重新排序。 此外，OLSR还支持协议扩展，如睡眠模式操作、多路路由等。这些扩展可以作为协议的补充而引入，而不会破坏与早期版本的向后兼容性 OLSR不需要对IP包的格式进行任何更改。因此，任何现有的IP堆栈都可以这样使用:协议仅与路由表管理交互。 MPR多点中继的思想是通过减少同一区域的冗余重传来最小化网络中泛滥消息的开销。网络中的每个节点在其对称的1跳邻居中选择一组节点，这些节点可以重新传输其消息。这组选定的邻居节点称为该节点的“多点中继”(MPR)集。节点N的邻居(不在其MPR集中)接收和处理广播消息，但不转发从节点N接收到的广播消息。 每个节点从它的1跳对称邻居中选择它的MPR集。选择这个集合时，它覆盖(在无线电范围方面)所有对称的严格2跳节点。N的MPR集合，记作MPR(N)，是N的对称1跳邻域的任意子集，满足以下条件:N的对称严格2跳邻域内的每个节点必须有一个指向MPR(N)的对称链接。MPR集越小，路由协议导致的控制流量开销越小。[2]给出了MPR选择算法的分析和实例。 每个节点维护选择它作为MPR的邻居集的信息。这个集合称为节点的“多点中继选择集合”(MPR选择集合)。节点从邻居定期接收的HELLO消息中获取此信息。 从节点N的MPR选择器中发出的广播消息，打算在整个网络中传播，如果节点N还没有接收到广播消息，则假定该广播消息由节点N重新发送。这个集合可以随时间改变(即，当节点选择另一个MPR-set时)，并由其HELLO消息中的选择器节点指示。 协议功能本节概述总体协议的功能。OLSR被模块化为功能的“核心”和一组辅助功能，这些功能是协议操作所必需的。 核心本身指定了能够在独立的MANET中提供路由的协议。每个辅助功能提供额外的功能，这些功能可能适用于特定的场景，例如，当一个节点提供MANET和另一个路由域之间的连接时。所有辅助功能都是兼容的，只要辅助功能的任何(子)集可以用核心实现即可。此外，该协议允许异构节点，即，实现辅助功能的不同子集的节点在网络中共存。将OLSR的功能划分为核心功能和一组辅助功能的目的是提供一个简单且易于理解的协议，并提供一种只在需要特定附加功能时增加复杂性的方法。 核心功能OLSR的核心功能指定了节点的行为，配备了参与MANET的OLSR接口，并运行OLSR作为路由协议。这包括OLSR协议消息的通用规范及其通过网络的传输，以及链路感知、拓扑扩散和路由计算。 具体来说，核心是由以下组件组成的： 分组格式和转发： ​ 包格式的通用规范和优化的洪泛机制是所有OLSR控制流量的传输机制 链路感知 ​ 链接感知是通过在接口上定期发送HELLO消息来实现的，通过这些接口检查连接性。为每个接口生成一个单独的HELLO消息，并根据第7节中的规定发出相应的HELLO消息。 ​ 由链路感应产生的是一个本地链路集，描述“本地接口”和“远程接口”之间的链路。，邻居节点上的接口。 ​ 如果链路层提供了足够的信息，则可以利用这些信息来填充本地链路集，而不是进行HELLO消息交换。 邻居检测 对于只有单个接口节点的网络，节点可以直接从作为链路感知的一部分交换的信息中扣除邻居集:根据定义，单个接口节点的“主地址”是该节点上唯一接口的地址。在具有多个接口节点的网络中，需要额外的信息才能将接口地址映射到主地址(从而映射到节点)。这些附加信息是通过第5节中描述的多个接口声明(MID)消息获得的。 MPR选择和MPR信号 MPR选择的目的是让一个节点选择它的邻居的一个子集，这样一个广播消息，由这些被选择的邻居重新传输，将被所有节点接收2跳。计算节点的MPR集时，对于每个接口，它都满足这个条件。执行此计算所需的信息是通过定期交换HELLO消息获得的，如第6节所述。MPR选择程序详见第8.3节。MPR信号是根据第6节的规定提供的。 拓扑控制消息扩散 拓扑控制消息是分散的，其目的是为网络中的每个节点提供足够的链路状态信息，以允许路由计算。拓扑控制消息在与第9节的规定相对应的情况下被扩散。 路由计算 OLSR协议术语node:一种MANET路由器 OLSR接口(OLSR interface):参与运行OLSR的MANET的网络设备。一个节点可以有多个OLSR接口，每个接口分配一个惟一的IP地址。 非OLSR接口(non OLSR interface):网络设备，不参与运行OLSR的MANET。一个节点可能有几个非OLSR接口(无线和/或有线)。来自这些接口的路由信息可以注入到OLSR路由域。 单个OLSR接口节点(single OLSR interface node):具有单个OLSR接口的节点，参与一个OLSR路由域。 多个OLSR接口节点(multiple OLSR interface node) 主地址（main address）：一个节点的主地址，将在OLSR中用于控制流量，作为该节点发出的所有消息的“始发者地址”。它是节点的一个OLSR接口的地址。单个OLSR接口节点必须使用其唯一OLSR接口的地址作为主地址。多个OLSR接口节点必须选择一个OLSR接口地址作为“主地址”(相当于“路由器ID”或“节点标识符”)。选择哪个地址并不重要，但是节点应该始终使用与其主地址相同的地址。 邻居节点（neighbor node） 二跳邻居节点（2-hop neighbor） 严格2-hop邻居（strict 2-hop neighbor）：一个2跳邻居，它不是节点本身，也不是节点的邻居，而且是邻居的邻居，其意愿不同于节点的WILL_NEVER。 multipoint relay (MPR) multipoint relay selector (MPR selector, MS)：选择其1跳邻居节点X作为其多点中继的节点将被称为节点X的多点中继选择器。 链路（link）：一个链接是一对OLSR接口(来自两个不同的节点)，它们可以相互监听对方的声音。，其中一个可以接收来自另一个的流量)。当一个节点的一个接口与另一个节点的一个接口有链接时，该节点被称为与另一个节点有链接 对称链路（symmetric link） 非对称链路（asymmetric link） 对称一跳邻居 对称二跳邻居 对称严格二跳邻居","categories":[{"name":"MANET","slug":"MANET","permalink":"https://goolory.github.io/categories/MANET/"}],"tags":[{"name":"OLSR","slug":"OLSR","permalink":"https://goolory.github.io/tags/OLSR/"}]},{"title":"使用nvm管理node_转","slug":"使用nvm管理node","date":"2019-11-22T14:23:12.000Z","updated":"2020-03-17T03:12:39.952Z","comments":true,"path":"2019/11/22/使用nvm管理node/","link":"","permalink":"https://goolory.github.io/2019/11/22/%E4%BD%BF%E7%94%A8nvm%E7%AE%A1%E7%90%86node/","excerpt":"","text":"nvm – nodeJS 管理工具1、安装 nvm 之后最好先删除下已安装的 node 和全局 node 模块：1234567891011#查看已经安装在全局的模块，以便删除这些全局模块后再按照不同的 node 版本重新进行全局安装npm ls -g --depth=0#删除全局 node_modules 目录sudo rm -rf /usr/local/lib/node_modules#删除 nodesudo rm /usr/local/bin/node#删除全局 node 模块注册的软链cd /usr/local/bin &amp;&amp; ls -l | grep &quot;../lib/node_modules/&quot; | awk &apos;&#123;print $9&#125;&apos;| xargs rm 2、安装nvm1curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.8/install.sh | bash 最新版本https://github.com/creationix/nvm/blob/master/README.md 3、查看安装如出现 1nvm: command not found 则 1vi .bash_profile .bash_profile 12export NVM_DIR=&quot;$HOME/.nvm&quot;[ -s &quot;$NVM_DIR/nvm.sh&quot; ] &amp;&amp; . &quot;$NVM_DIR/nvm.sh&quot; 1source .bash_profile 4、使用nvm1234567891011nvm install stable # 安装最新稳定版 node，现在是 5.0.0nvm install 4.2.2 # 安装 4.2.2 版本nvm install 0.12.7 # 安装 0.12.7 版本# 特别说明：以下模块安装仅供演示说明，并非必须安装模块nvm use 4 # 切换至 4.2.2 版本npm install -g mz-fis # 安装 mz-fis 模块至全局目录，安装完成的路径是 /Users/&lt;你的用户名&gt;/.nvm/versions/node/v0.12.7/lib/mz-fisnvm use 0 # 切换至 0.12.7 版本npm install -g react-native-cli #安装 react-native-cli 模块至全局目录，安装完成的路径是 /Users/&lt;你的用户名&gt;/.nvm/versions/node/v4.2.2/lib/react-native-clinvm alias default 0.12.7 #设置默认 node 版本为 0.12.7 文章来源https://www.jianshu.com/p/04d31f6c22bd","categories":[{"name":"工具","slug":"工具","permalink":"https://goolory.github.io/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"node","slug":"node","permalink":"https://goolory.github.io/tags/node/"}]},{"title":"Linux切换Python版本_转","slug":"Linux切换Python版本","date":"2019-11-22T14:20:33.000Z","updated":"2020-03-17T03:12:39.929Z","comments":true,"path":"2019/11/22/Linux切换Python版本/","link":"","permalink":"https://goolory.github.io/2019/11/22/Linux%E5%88%87%E6%8D%A2Python%E7%89%88%E6%9C%AC/","excerpt":"","text":"Linux(ubuntu18.04)切换python版本前言Ubuntu18.04系统在安装python时会安装两个版本:2.7和3.6．默认情况下系统环境使用的是python2，但是我们有时需要使用python3来作为我们的开发环境，所以需要自由切换python版本． python2切换成python312sudo update-alternatives --install /usr/bin/python python /usr/bin/python2 100sudo update-alternatives --install /usr/bin/python python /usr/bin/python3 150 执行上面两句命令即可将2.7版本切换成python3.6版本，想要查看是否切换成功： 123shanlei@shanlei-Lenovo-ideapad-110-15ISK:~$ python --versionPython 3.6.5shanlei@shanlei-Lenovo-ideapad-110-15ISK:~$ python3切换成python21234567891011121314shanlei@shanlei-Lenovo-ideapad-110-15ISK:~$ sudo update-alternatives --config python[sudo] shanlei 的密码： 有 2 个候选项可用于替换 python (提供 /usr/bin/python)。 选择 路径 优先级 状态------------------------------------------------------------* 0 /usr/bin/python3 150 自动模式 1 /usr/bin/python2 100 手动模式 2 /usr/bin/python3 150 手动模式 要维持当前值[*]请按&lt;回车键&gt;，或者键入选择的编号：1update-alternatives: 使用 /usr/bin/python2 来在手动模式中提供 /usr/bin/python (python)shanlei@shanlei-Lenovo-ideapad-110-15ISK:~$ python --versionPython 2.7.15rc1 之后我们在切换python版本时就可以使用这个命令键入选择进行切换了： 1sudo update-alternatives --config python 文章来源Linux(ubuntu18.04)切换python版本","categories":[{"name":"运维","slug":"运维","permalink":"https://goolory.github.io/categories/%E8%BF%90%E7%BB%B4/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://goolory.github.io/tags/Linux/"}]},{"title":"快速排序","slug":"quickSort","date":"2019-11-22T14:06:28.000Z","updated":"2020-03-17T03:12:39.902Z","comments":true,"path":"2019/11/22/quickSort/","link":"","permalink":"https://goolory.github.io/2019/11/22/quickSort/","excerpt":"","text":"快速排序快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。 算法描述 从数列中挑出一个元素，称为 “基准”（pivot）； 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作； 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。 代码123456789101112131415161718192021222324//快速排序 private int quickSort(int[] a, int l, int r)&#123; int i = l; for (int j = l; j&lt;r; j++) &#123; if (a[j] &lt; a[r]) &#123; int temp = a[i]; a[i] = a[j]; a[j] = temp; i++; &#125; &#125; int temp = a[i]; a[i] = a[r]; a[r] = temp; return i; &#125; public void quick(int[] a, int l, int r) &#123; if (l &lt; r) &#123; int q = quickSort(a, l, r); quick(a, l, q-1); quick(a, q+1, r); &#125; &#125; 总结分段排序时以末尾元素为基准，因为这个元素最后一个移动，可以保证基准元素固定，无需去找。","categories":[{"name":"算法","slug":"算法","permalink":"https://goolory.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://goolory.github.io/tags/Java/"}]},{"title":"归并排序","slug":"mergeSort","date":"2019-11-22T14:06:11.000Z","updated":"2020-03-17T03:05:56.844Z","comments":true,"path":"2019/11/22/mergeSort/","link":"","permalink":"https://goolory.github.io/2019/11/22/mergeSort/","excerpt":"","text":"归并排序归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。 算法描述 把长度为n的输入序列分成两个长度为n/2的子序列； 对这两个子序列分别采用归并排序； 将两个排序好的子序列合并成一个最终的排序序列。 代码1234567891011121314151617181920212223242526272829303132333435//归并排序 public int[] mergeSort(int[] a, int low, int high) &#123; int mid = (low+high) / 2; if (low &lt; high) &#123; mergeSort(a, low, mid); mergeSort(a, mid+1, high); merge(a, low, mid, high); &#125; return a; &#125; private void merge(int[] a, int low, int mid, int high) &#123; int[] temp = new int[high-low+1]; int i = low; int j = mid + 1; int k = 0; while (i &lt;= mid &amp;&amp; j&lt;=high) &#123; if (a[i] &lt; a[j]) &#123; temp[k++] = a[i++]; &#125; else &#123; temp[k++] = a[j++]; &#125; &#125; while (i&lt;=mid) &#123; temp[k++] = a[i++]; &#125; while (j&lt;=high) &#123; temp[k++] = a[j++]; &#125; for(int x = 0; x&lt;temp.length; x++) &#123; a[x+low] = temp[x]; &#125; &#125; 总结递归分段，将对应的两段先排序","categories":[{"name":"算法","slug":"算法","permalink":"https://goolory.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://goolory.github.io/tags/Java/"}]},{"title":"希尔排序","slug":"shellSort","date":"2019-11-22T14:05:48.000Z","updated":"2020-03-17T03:12:39.946Z","comments":true,"path":"2019/11/22/shellSort/","link":"","permalink":"https://goolory.github.io/2019/11/22/shellSort/","excerpt":"","text":"希尔排序算法描述先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述： 选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1； 按增量序列个数k，对序列进行k 趟排序； 每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。 代码1234567891011121314//希尔排序 //var Java10新类型 让编译器自己推断类型 public void shellSort(int[] a) &#123; for (var gap = a.length / 2; gap &gt; 0; gap = gap / 2) &#123; for (var i = gap; i&lt;a.length; i++) &#123; var j = i; var current = a[i]; while (j - gap &gt;= 0 &amp;&amp; current &lt; a[j-gap]) &#123; a[j] = a[j - gap]; j = j - gap; &#125; a[j] = current; &#125; &#125; &#125; 总结根据间隔分组，分组后排序，减小分组间隔分组后使用插入排序","categories":[{"name":"算法","slug":"算法","permalink":"https://goolory.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://goolory.github.io/tags/Java/"}]},{"title":"选择排序","slug":"SelectionSort","date":"2019-11-22T14:02:32.000Z","updated":"2020-03-17T03:05:56.837Z","comments":true,"path":"2019/11/22/SelectionSort/","link":"","permalink":"https://goolory.github.io/2019/11/22/SelectionSort/","excerpt":"","text":"选择排序算法描述 n个记录的直接选择排序可经过n-1趟直接选择排序得到有序结果。具体算法描述如下： 初始状态：无序区为R[1..n]，有序区为空；第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区； n-1趟结束，数组有序化了。 代码12345678910111213//选择排序 从小到大 public void selectionSort(int[] a) &#123; for (int i=0;i&lt;a.length-1; i++) &#123; for (int j=i+1; j&lt;a.length; j++) &#123; if (a[i] &gt; a[j]) &#123; int temp = a[i]; a[i] = a[j]; a[j] = temp; &#125; &#125; &#125; print(a); &#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://goolory.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://goolory.github.io/tags/Java/"}]},{"title":"冒泡排序","slug":"冒泡排序","date":"2019-11-22T12:50:48.000Z","updated":"2020-03-17T03:05:56.869Z","comments":true,"path":"2019/11/22/冒泡排序/","link":"","permalink":"https://goolory.github.io/2019/11/22/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/","excerpt":"","text":"冒泡排序算法描述 比较相邻的元素。如果第一个比第二个大，就交换它们两个； 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数； 针对所有的元素重复以上的步骤，除了最后一个； 重复步骤1~3，直到排序完成。 代码1234567891011121314//冒泡排序 从小到大 public void bubbleSort(int[] a) &#123; for (int j=0; j&lt;a.length-1;j++)&#123; for(int i=0;i&lt;a.length-1-j;i++) &#123; if (a[i] &gt; a[i+1]) &#123; int temp = a[i]; a[i] = a[i+1]; a[i+1] = temp; &#125; &#125; &#125; print(a); &#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://goolory.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://goolory.github.io/tags/Java/"}]},{"title":"插入排序","slug":"插入排序","date":"2019-11-22T12:40:41.000Z","updated":"2020-03-17T03:05:56.876Z","comments":true,"path":"2019/11/22/插入排序/","link":"","permalink":"https://goolory.github.io/2019/11/22/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/","excerpt":"","text":"插入排序具体算法描述如下： 从第一个元素开始，该元素可以认为已经被排序； 取出下一个元素，在已经排序的元素序列中从后向前扫描； 如果该元素（已排序）大于新元素，将该元素移到下一位置； 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置； 将新元素插入到该位置后； 重复步骤2~5。 代码我的 1234567891011121314//直接插入排序 从大到小 public void insertSort(int[] a) &#123; for(int i=1; i&lt;a.length; i++)&#123; for (int j=i; j&gt;0; j--)&#123; if (a[j-1] &lt; a[j]) &#123; int temp = a[j-1]; a[j-1] = a[j]; a[j] = temp; &#125; &#125; &#125; print(a); &#125; 123456789101112131415//漂亮的代码 从小到大 public void insertNB(int[] a) &#123; int insertNum; for(int i=1; i&lt;a.length; i++) &#123; insertNum = a[i]; int j = i - 1; while (j&gt;=0 &amp;&amp; a[j]&gt;insertNum) &#123; a[j+1] = a[j]; j--; &#125; a[j+1] = insertNum; &#125; print(a); &#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://goolory.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://goolory.github.io/tags/Java/"}]}]}